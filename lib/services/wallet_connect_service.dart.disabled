import 'dart:convert';
import 'package:walletconnect_flutter_v2/walletconnect_flutter_v2.dart';
import 'package:logger/logger.dart';
import 'package:web3dart/web3dart.dart';
import 'web3_service.dart';

/// Ø³Ø±ÙˆÛŒØ³ WalletConnect Ø¨Ø±Ø§ÛŒ Ø§ØªØµØ§Ù„ Ú©ÛŒÙ Ù¾ÙˆÙ„â€ŒÙ‡Ø§ÛŒ Ø®Ø§Ø±Ø¬ÛŒ
class WalletConnectService {
  static WalletConnectService? _instance;
  static WalletConnectService get instance => _instance ??= WalletConnectService._();
  WalletConnectService._();

  Web3App? _web3App;
  SessionData? _currentSession;
  
  // Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ù¾Ø±ÙˆÚ˜Ù‡
  static const String projectId = 'YOUR_PROJECT_ID'; // Ø¨Ø§ÛŒØ¯ Ø§Ø² WalletConnect Cloud Ø¯Ø±ÛŒØ§ÙØª Ø´ÙˆØ¯
  static const String bundleId = 'com.example.adl';
  static const String appName = 'LAXCE DEX';
  static const String appDescription = 'Decentralized Exchange';
  static const String appUrl = 'https://laxce.com';
  static const String appIcon = 'https://laxce.com/icon.png';

  // ==================== INITIALIZATION ====================

  /// Ù…Ù‚Ø¯Ø§Ø±Ø¯Ù‡ÛŒ Ø§ÙˆÙ„ÛŒÙ‡ WalletConnect
  Future<void> initialize() async {
    try {
      _web3App = await Web3App.createInstance(
        projectId: projectId,
        logLevel: Level.error,
        metadata: const PairingMetadata(
          name: appName,
          description: appDescription,
          url: appUrl,
          icons: [appIcon],
          redirect: Redirect(
            native: '$bundleId://',
            universal: 'https://laxce.com/app',
          ),
        ),
      );

      // ØªÙ†Ø¸ÛŒÙ… event listeners
      _setupEventListeners();
      
      // Ø¨Ø±Ø±Ø³ÛŒ session Ù‡Ø§ÛŒ Ù…ÙˆØ¬ÙˆØ¯
      await _checkExistingSessions();
      
      print('âœ… WalletConnect initialized successfully');
    } catch (e) {
      print('âŒ Error initializing WalletConnect: $e');
      rethrow;
    }
  }

  /// ØªÙ†Ø¸ÛŒÙ… event listeners
  void _setupEventListeners() {
    _web3App?.onSessionConnect.subscribe(_onSessionConnect);
    _web3App?.onSessionDelete.subscribe(_onSessionDelete);
    _web3App?.onSessionEvent.subscribe(_onSessionEvent);
    _web3App?.onSessionUpdate.subscribe(_onSessionUpdate);
  }

  /// Ø¨Ø±Ø±Ø³ÛŒ session Ù‡Ø§ÛŒ Ù…ÙˆØ¬ÙˆØ¯
  Future<void> _checkExistingSessions() async {
    final sessions = _web3App?.sessions.getAll();
    if (sessions != null && sessions.isNotEmpty) {
      _currentSession = sessions.first;
      print('ğŸ”— Found existing session: ${_currentSession?.topic}');
    }
  }

  // ==================== CONNECTION MANAGEMENT ====================

  /// Ø§ØªØµØ§Ù„ Ø¨Ù‡ Ú©ÛŒÙ Ù¾ÙˆÙ„
  Future<String> connect() async {
    try {
      if (_web3App == null) {
        throw Exception('WalletConnect not initialized');
      }

      // Ù¾Ø§Ú© Ú©Ø±Ø¯Ù† session Ù‡Ø§ÛŒ Ù‚Ø¯ÛŒÙ…ÛŒ
      final sessions = _web3App!.sessions.getAll();
      for (final session in sessions) {
        await _web3App!.disconnectSession(
          topic: session.topic,
          reason: const WalletConnectError(
            code: 6000,
            message: 'User disconnected',
          ),
        );
      }

      // Ø§ÛŒØ¬Ø§Ø¯ namespace Ø¬Ø¯ÛŒØ¯
      final namespace = {
        'eip155': const RequiredNamespace(
          chains: ['eip155:31337'], // Hardhat local network
          methods: [
            'eth_sendTransaction',
            'eth_signTransaction',
            'eth_sign',
            'personal_sign',
            'eth_signTypedData',
          ],
          events: ['chainChanged', 'accountsChanged'],
        ),
      };

      // Ø§ÛŒØ¬Ø§Ø¯ session Ø¬Ø¯ÛŒØ¯
      final ConnectResponse connectResponse = await _web3App!.connect(
        requiredNamespaces: namespace,
      );

      final uri = connectResponse.uri;
      if (uri == null) {
        throw Exception('Failed to generate connection URI');
      }

      print('ğŸ”— Connection URI generated: $uri');
      
      // Ø§Ù†ØªØ¸Ø§Ø± Ø¨Ø±Ø§ÛŒ ØªØ§ÛŒÛŒØ¯ Ø§ØªØµØ§Ù„
      final SessionData session = await connectResponse.session.future;
      _currentSession = session;
      
      print('âœ… WalletConnect session established');
      return _getConnectedAddress();
      
    } catch (e) {
      print('âŒ Error connecting wallet: $e');
      rethrow;
    }
  }

  /// Ù‚Ø·Ø¹ Ø§ØªØµØ§Ù„
  Future<void> disconnect() async {
    try {
      if (_currentSession != null) {
        await _web3App?.disconnectSession(
          topic: _currentSession!.topic,
          reason: const WalletConnectError(
            code: 6000,
            message: 'User disconnected',
          ),
        );
        _currentSession = null;
        print('âœ… WalletConnect session disconnected');
      }
    } catch (e) {
      print('âŒ Error disconnecting wallet: $e');
      rethrow;
    }
  }

  // ==================== GETTERS ====================

  /// Ø¢ÛŒØ§ Ù…ØªØµÙ„ Ø§Ø³Øª
  bool get isConnected => _currentSession != null;

  /// Ø¯Ø±ÛŒØ§ÙØª Ø¢Ø¯Ø±Ø³ Ù…ØªØµÙ„ Ø´Ø¯Ù‡
  String _getConnectedAddress() {
    if (_currentSession == null) return '';
    
    final accounts = _currentSession!.namespaces['eip155']?.accounts;
    if (accounts == null || accounts.isEmpty) return '';
    
    // Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø¢Ø¯Ø±Ø³ Ø§Ø² ÙØ±Ù…Øª: eip155:chainId:address
    final accountString = accounts.first;
    final addressPart = accountString.split(':').last;
    return addressPart;
  }

  /// Ø¯Ø±ÛŒØ§ÙØª Ø¢Ø¯Ø±Ø³ Ú©ÛŒÙ Ù¾ÙˆÙ„
  String? get connectedAddress => isConnected ? _getConnectedAddress() : null;

  // ==================== TRANSACTION METHODS ====================

  /// Ø§Ø±Ø³Ø§Ù„ ØªØ±Ø§Ú©Ù†Ø´
  Future<String> sendTransaction({
    required String to,
    required String value,
    String? data,
    String? gasLimit,
    String? gasPrice,
  }) async {
    try {
      if (!isConnected) {
        throw Exception('Wallet not connected');
      }

      final transaction = {
        'from': _getConnectedAddress(),
        'to': to,
        'value': value,
        if (data != null) 'data': data,
        if (gasLimit != null) 'gas': gasLimit,
        if (gasPrice != null) 'gasPrice': gasPrice,
      };

      final result = await _web3App!.request(
        topic: _currentSession!.topic,
        chainId: 'eip155:31337',
        request: SessionRequestParams(
          method: 'eth_sendTransaction',
          params: [transaction],
        ),
      );

      return result.toString();
    } catch (e) {
      print('âŒ Error sending transaction: $e');
      rethrow;
    }
  }

  /// Ø§Ù…Ø¶Ø§ÛŒ Ù¾ÛŒØ§Ù…
  Future<String> signMessage(String message) async {
    try {
      if (!isConnected) {
        throw Exception('Wallet not connected');
      }

      final result = await _web3App!.request(
        topic: _currentSession!.topic,
        chainId: 'eip155:31337',
        request: SessionRequestParams(
          method: 'personal_sign',
          params: [message, _getConnectedAddress()],
        ),
      );

      return result.toString();
    } catch (e) {
      print('âŒ Error signing message: $e');
      rethrow;
    }
  }

  // ==================== EVENT HANDLERS ====================

  void _onSessionConnect(SessionConnect? event) {
    print('ğŸ”— Session connected: ${event?.session.topic}');
  }

  void _onSessionDelete(SessionDelete? event) {
    print('âŒ Session deleted: ${event?.topic}');
    _currentSession = null;
  }

  void _onSessionEvent(SessionEvent? event) {
    print('ğŸ“¡ Session event: ${event?.name}');
  }

  void _onSessionUpdate(SessionUpdate? event) {
    print('ğŸ”„ Session updated: ${event?.topic}');
  }

  // ==================== UTILITY METHODS ====================

  /// Ø¯Ø±ÛŒØ§ÙØª URI Ø¨Ø±Ø§ÛŒ Ø§ØªØµØ§Ù„
  Future<String> getConnectionUri() async {
    try {
      if (_web3App == null) {
        throw Exception('WalletConnect not initialized');
      }

      final namespace = {
        'eip155': const RequiredNamespace(
          chains: ['eip155:31337'], // Hardhat local network
          methods: [
            'eth_sendTransaction',
            'eth_signTransaction',
            'eth_sign',
            'personal_sign',
            'eth_signTypedData',
          ],
          events: ['chainChanged', 'accountsChanged'],
        ),
      };

      final ConnectResponse connectResponse = await _web3App!.connect(
        requiredNamespaces: namespace,
      );

      return connectResponse.uri?.toString() ?? '';
    } catch (e) {
      print('âŒ Error generating connection URI: $e');
      rethrow;
    }
  }

  /// Ù¾Ø§Ú© Ú©Ø±Ø¯Ù† Ù…Ù†Ø§Ø¨Ø¹
  void dispose() {
    _web3App?.onSessionConnect.unsubscribe(_onSessionConnect);
    _web3App?.onSessionDelete.unsubscribe(_onSessionDelete);
    _web3App?.onSessionEvent.unsubscribe(_onSessionEvent);
    _web3App?.onSessionUpdate.unsubscribe(_onSessionUpdate);
  }
} 